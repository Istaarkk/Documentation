## ğŸ§  MÃ©moire, Pile et Registres en Exploitation Windows (x86)

---

### ğŸ§± **1. Organisation de la MÃ©moire dâ€™un Programme**

Lorsquâ€™un programme est exÃ©cutÃ©, un espace mÃ©moire lui est allouÃ©. Ce dernier est structurÃ© en diffÃ©rentes zones avec des rÃ´les bien dÃ©finis.

Voici une image pour illustrer comment la mÃ©moire:
![[Pasted image 20250513215957.png]]
#### ğŸ“Š Structure typique de la mÃ©moire sous Windows (32 bits) :

```rust
| Adresse        | Segment                                |
|----------------|----------------------------------------|
| 0xFFFFFFFF     | **Kernel Memory Space** (Espace noyau) |
| 0x7FFFFFFF     |                                        |
| 0x7FFDF000     | Dynamic Link Library (DLL)             |
|                |                                        |
|                | Heap                                   |
|                | Thread Environment Block (TEB)         |
|                | Process Environment Block (PEB)        |
| 0x00400000     | Program Image                          |
|                | Stack                                  |
| 0x00000000     | Adresse mÃ©moire basse                  |

```

### ğŸ“š **2. La Stack (Pile)**

Quand un **thread** sâ€™exÃ©cute, il peut appeler du **code contenu dans le programme lui-mÃªme** (le _Program Image_) ou dans des **bibliothÃ¨ques dynamiques (DLL)**.

#### ğŸ§µ Chaque thread :

- PossÃ¨de sa **propre stack**, qui lui est attribuÃ©e Ã  sa crÃ©ation.
    
- Cette stack sert Ã  :
    
    - **Stocker les paramÃ¨tres** des fonctions appelÃ©es
        
    - **Garder lâ€™adresse de retour**
        
    - **Sauvegarder les registres**
        
    - **Allouer les variables locales**
        

> ğŸ§  **Important** :  
> Lorsque le thread appelle une fonction â€” quâ€™elle provienne dâ€™une DLL comme `kernel32.dll`, `user32.dll`, etc., ou du programme lui-mÃªme â€” **cette fonction utilise la stack du thread** pour exÃ©cuter ses opÃ©rations.

#### âš™ï¸ SchÃ©ma fonctionnel :

text

CopierModifier

`Thread â†’ Appelle fonction (DLL ou code local) â†’  â†’ Stack alloue :     - adresse de retour    - paramÃ¨tres    - variables locales`

#### ğŸ“Œ CaractÃ©ristiques de la stack :

- Fonctionne en **LIFO** (_Last In, First Out_)
    
- ModifiÃ©e par instructions `PUSH` / `POP`
    
- Sa taille peut varier (ex. : 1 Mo par dÃ©faut sur Windows)

### ğŸ§¬ **3. Calling Convention (Convention dâ€™appel)**

DÃ©finit comment :

- Les **paramÃ¨tres** sont passÃ©s aux fonctions
    
- Le **rÃ©sultat** est retournÃ©
    
- La **pile est nettoyÃ©e** aprÃ¨s lâ€™appel
    

#### ğŸ”§ Exemples courants (x86) :

- `cdecl` : les paramÃ¨tres sont passÃ©s sur la pile, le **caller** nettoie la pile
    
- `stdcall` : les paramÃ¨tres sont sur la pile, le **callee** nettoie
    
- `fastcall` : certains paramÃ¨tres sont passÃ©s via **registres (ECX, EDX)**
    

> ğŸ“Œ Lâ€™architecture **x86** supporte plusieurs conventions dâ€™appel.

### ğŸ” **4. Function Return Mechanics**

Lorsquâ€™une fonction est appelÃ©e :

- Son **adresse de retour** est poussÃ©e sur la pile
    
- Elle y place ses paramÃ¨tres et variables locales

![[Pasted image 20250513224632.png]]
| Adresse               | Valeur         | RÃ´le                             |
|-----------------------|----------------|----------------------------------|
| [EBP+12]              | 0xFFFFFFFF     | ParamÃ¨tre 3                      |
| [EBP+8]               | 0x00001000     | ParamÃ¨tre 2                      |
| [EBP+4]               | 0x00000040     | ParamÃ¨tre 1                      |
| [EBP]                 | 0x00401024     | Adresse de retour (â†’ EIP)        |


### ğŸ§® **5. Registres du CPU (x86 - 32 bits)**

|Registre 32 bits|16 bits|8 bits haut|8 bits bas|Description|
|---|---|---|---|---|
|**EAX**|AX|AH|AL|Accumulateur (arithmÃ©tique)|
|**EBX**|BX|BH|BL|Base pointer (mÃ©moire)|
|**ECX**|CX|CH|CL|Compteur (boucles, shift)|
|**EDX**|DX|DH|DL|DonnÃ©es (I/O, div/mul)|
|**ESI**|SI|â€”|â€”|Source index (string ops)|
|**EDI**|DI|â€”|â€”|Destination index|
|**ESP**|SP|â€”|â€”|Stack Pointer|
|**EBP**|BP|â€”|â€”|Base Pointer|
|**EIP**|IP|â€”|â€”|Instruction Pointer|
EAX --> L'accumulateur c'est le registres pour les instruction logiques et arithmetique

EBX --> Le registre de Base pointeur pour les adresse mÃ©moires 

ECX --> Le registres de compteur pour les boucles

EDX --> Le registre de Data pour les ports les adresses les mutliplication / Division

ESI --> Le pointeur d'adresse de la data ainsi que la source pour strncpy

EDI --> Le registre de destination d'index c'est le pointeur d'adresse de Data et la destination de 
strncpy

ESP --> Le pointeur de la stack, il pointe sur une adresse de la stack 

EIP --> Le pointeur d'instruction, il pointe sur l'instruction en cours d'execution


### ğŸ§· DÃ©tails supplÃ©mentaires :

#### ğŸ”¹ Pointeurs :

Un **pointeur** est une **adresse mÃ©moire**. Lorsquâ€™un registre "pointe", il contient une adresse de mÃ©moire vers une variable, une fonction, ou une instruction.

#### ğŸ”¹ Composition des registres :
```rust
EAX (32 bits)
â”œâ”€â”€ AX (16 bits)
â”‚   â”œâ”€â”€ AH (8 bits, haut)
â”‚   â””â”€â”€ AL (8 bits, bas)

```
![[Pasted image 20250513230114.png]]

EAX (32 bits) est divisÃ© en plusieurs sous-parties :

|Bits|Nom du registre|Taille|
|---|---|---|
|31 - 16|(non nommÃ© ici)|16 bits|
|15 - 8|AH|8 bits|
|7 - 0|AL|8 bits|

- **AX** = combinaison de **AH** (8 bits) et **AL** (8 bits) â†’ **AX** est un registre de 16 bits.
- **EAX** = registre complet de 32 bits.
ğŸ” Exemple visuel de structure des registres :

```rust
[ EAX (32 bits) ]
     â†“
[  AH  |  AL  ] = AX (16 bits)
```
